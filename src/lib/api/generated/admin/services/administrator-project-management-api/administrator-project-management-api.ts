/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  APIResponseString,
  APIResponseVoid,
  CheckProjectNameParams,
  GetListOfProjectHistoryParams,
  GetListOfProjectsParams,
  GetProjectHistoryResponse,
  GetProjectResponse,
  PostProjectRequest,
  PostProjectResponse,
  PutProjectRequest,
  PutProjectResponse,
  SearchHistoriesParams
} from '../../models'
import { adminAxios } from '../../../../../axiosClient';



/**
 * ÌîÑÎ°úÏ†ùÌä∏ idÎ•º ÌÜµÌï¥ ÌîÑÎ°úÏ†ùÌä∏ ÏÉÅÏÑ∏ Ï°∞ÌöåÌï®
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const readProject = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return adminAxios<GetProjectResponse>(
      {url: `/api/admin/projects/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getReadProjectQueryKey = (id: number,) => {
    return [`/api/admin/projects/${id}`] as const;
    }

    
export const getReadProjectInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof readProject>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadProjectQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readProject>>> = ({ signal }) => readProject(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadProjectInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof readProject>>>
export type ReadProjectInfiniteQueryError = unknown


export function useReadProjectInfinite<TData = InfiniteData<Awaited<ReturnType<typeof readProject>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readProject>>,
          TError,
          Awaited<ReturnType<typeof readProject>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadProjectInfinite<TData = InfiniteData<Awaited<ReturnType<typeof readProject>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readProject>>,
          TError,
          Awaited<ReturnType<typeof readProject>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadProjectInfinite<TData = InfiniteData<Awaited<ReturnType<typeof readProject>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useReadProjectInfinite<TData = InfiniteData<Awaited<ReturnType<typeof readProject>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadProjectInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getReadProjectQueryOptions = <TData = Awaited<ReturnType<typeof readProject>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadProjectQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readProject>>> = ({ signal }) => readProject(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadProjectQueryResult = NonNullable<Awaited<ReturnType<typeof readProject>>>
export type ReadProjectQueryError = unknown


export function useReadProject<TData = Awaited<ReturnType<typeof readProject>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readProject>>,
          TError,
          Awaited<ReturnType<typeof readProject>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadProject<TData = Awaited<ReturnType<typeof readProject>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readProject>>,
          TError,
          Awaited<ReturnType<typeof readProject>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadProject<TData = Awaited<ReturnType<typeof readProject>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useReadProject<TData = Awaited<ReturnType<typeof readProject>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readProject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadProjectQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ÌîÑÎ°úÏ†ùÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
 */
export const updateProject = (
    id: number,
    putProjectRequest: PutProjectRequest,
 ) => {
      
      
      return adminAxios<PutProjectResponse>(
      {url: `/api/admin/projects/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putProjectRequest
    },
      );
    }
  


export const getUpdateProjectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProject>>, TError,{id: number;data: PutProjectRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateProject>>, TError,{id: number;data: PutProjectRequest}, TContext> => {
    
const mutationKey = ['updateProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProject>>, {id: number;data: PutProjectRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProject(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateProject>>>
    export type UpdateProjectMutationBody = PutProjectRequest
    export type UpdateProjectMutationError = unknown

    /**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
 */
export const useUpdateProject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProject>>, TError,{id: number;data: PutProjectRequest}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateProject>>,
        TError,
        {id: number;data: PutProjectRequest},
        TContext
      > => {

      const mutationOptions = getUpdateProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * ÌîÑÎ°úÏ†ùÌä∏ ÏÇ≠Ï†ú
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏÇ≠Ï†ú
 */
export const deleteProject = (
    id: number,
 ) => {
      
      
      return adminAxios<APIResponseVoid>(
      {url: `/api/admin/projects/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProjectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProject>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteProject>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['deleteProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProject>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProject(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProject>>>
    
    export type DeleteProjectMutationError = unknown

    /**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏÇ≠Ï†ú
 */
export const useDeleteProject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProject>>, TError,{id: number}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteProject>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * ÌîÑÎ°úÏ†ùÌä∏ ÌéòÏù¥ÏßÄ Î¶¨Ïä§Ìä∏Î•º Ï°∞Ìöå
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÌéòÏù¥ÏßÄ Ï°∞Ìöå
 */
export const getListOfProjects = (
    params: GetListOfProjectsParams,
 signal?: AbortSignal
) => {
      
      
      return adminAxios<GetProjectResponse>(
      {url: `/api/admin/projects`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetListOfProjectsQueryKey = (params: GetListOfProjectsParams,) => {
    return [`/api/admin/projects`, ...(params ? [params]: [])] as const;
    }

    
export const getGetListOfProjectsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjects>>>, TError = unknown>(params: GetListOfProjectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetListOfProjectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getListOfProjects>>> = ({ signal }) => getListOfProjects(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetListOfProjectsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getListOfProjects>>>
export type GetListOfProjectsInfiniteQueryError = unknown


export function useGetListOfProjectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjects>>>, TError = unknown>(
 params: GetListOfProjectsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListOfProjects>>,
          TError,
          Awaited<ReturnType<typeof getListOfProjects>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetListOfProjectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjects>>>, TError = unknown>(
 params: GetListOfProjectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListOfProjects>>,
          TError,
          Awaited<ReturnType<typeof getListOfProjects>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetListOfProjectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjects>>>, TError = unknown>(
 params: GetListOfProjectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÌéòÏù¥ÏßÄ Ï°∞Ìöå
 */

export function useGetListOfProjectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjects>>>, TError = unknown>(
 params: GetListOfProjectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetListOfProjectsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetListOfProjectsQueryOptions = <TData = Awaited<ReturnType<typeof getListOfProjects>>, TError = unknown>(params: GetListOfProjectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetListOfProjectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getListOfProjects>>> = ({ signal }) => getListOfProjects(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetListOfProjectsQueryResult = NonNullable<Awaited<ReturnType<typeof getListOfProjects>>>
export type GetListOfProjectsQueryError = unknown


export function useGetListOfProjects<TData = Awaited<ReturnType<typeof getListOfProjects>>, TError = unknown>(
 params: GetListOfProjectsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListOfProjects>>,
          TError,
          Awaited<ReturnType<typeof getListOfProjects>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetListOfProjects<TData = Awaited<ReturnType<typeof getListOfProjects>>, TError = unknown>(
 params: GetListOfProjectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListOfProjects>>,
          TError,
          Awaited<ReturnType<typeof getListOfProjects>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetListOfProjects<TData = Awaited<ReturnType<typeof getListOfProjects>>, TError = unknown>(
 params: GetListOfProjectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÌéòÏù¥ÏßÄ Ï°∞Ìöå
 */

export function useGetListOfProjects<TData = Awaited<ReturnType<typeof getListOfProjects>>, TError = unknown>(
 params: GetListOfProjectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjects>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetListOfProjectsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ÌîÑÎ°úÏ†ùÌä∏Î•º ÏÉùÏÑ±ÌïòÎäî api
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ±
 */
export const newProject = (
    postProjectRequest: PostProjectRequest,
 signal?: AbortSignal
) => {
      
      
      return adminAxios<PostProjectResponse>(
      {url: `/api/admin/projects`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postProjectRequest, signal
    },
      );
    }
  


export const getNewProjectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof newProject>>, TError,{data: PostProjectRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof newProject>>, TError,{data: PostProjectRequest}, TContext> => {
    
const mutationKey = ['newProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof newProject>>, {data: PostProjectRequest}> = (props) => {
          const {data} = props ?? {};

          return  newProject(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NewProjectMutationResult = NonNullable<Awaited<ReturnType<typeof newProject>>>
    export type NewProjectMutationBody = PostProjectRequest
    export type NewProjectMutationError = unknown

    /**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ±
 */
export const useNewProject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof newProject>>, TError,{data: PostProjectRequest}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof newProject>>,
        TError,
        {data: PostProjectRequest},
        TContext
      > => {

      const mutationOptions = getNewProjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†•ÏùÑ ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• idÎ°ú ÏÉÅÏÑ∏ Ï°∞Ìöå
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const getProjectHistory = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return adminAxios<GetProjectHistoryResponse>(
      {url: `/api/admin/projects/${id}/histories`, method: 'GET', signal
    },
      );
    }
  

export const getGetProjectHistoryQueryKey = (id: number,) => {
    return [`/api/admin/projects/${id}/histories`] as const;
    }

    
export const getGetProjectHistoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProjectHistory>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectHistoryQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectHistory>>> = ({ signal }) => getProjectHistory(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProjectHistoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectHistory>>>
export type GetProjectHistoryInfiniteQueryError = unknown


export function useGetProjectHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProjectHistory>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectHistory>>,
          TError,
          Awaited<ReturnType<typeof getProjectHistory>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProjectHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProjectHistory>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectHistory>>,
          TError,
          Awaited<ReturnType<typeof getProjectHistory>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProjectHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProjectHistory>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetProjectHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProjectHistory>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProjectHistoryInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProjectHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getProjectHistory>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectHistoryQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectHistory>>> = ({ signal }) => getProjectHistory(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProjectHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectHistory>>>
export type GetProjectHistoryQueryError = unknown


export function useGetProjectHistory<TData = Awaited<ReturnType<typeof getProjectHistory>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectHistory>>,
          TError,
          Awaited<ReturnType<typeof getProjectHistory>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProjectHistory<TData = Awaited<ReturnType<typeof getProjectHistory>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectHistory>>,
          TError,
          Awaited<ReturnType<typeof getProjectHistory>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProjectHistory<TData = Awaited<ReturnType<typeof getProjectHistory>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetProjectHistory<TData = Awaited<ReturnType<typeof getProjectHistory>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectHistory>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProjectHistoryQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• ÌéòÏù¥ÏßÄÎ•º Ï°∞Ìöå
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• ÌéòÏù¥ÏßÄ Ï°∞Ìöå
 */
export const getListOfProjectHistory = (
    params: GetListOfProjectHistoryParams,
 signal?: AbortSignal
) => {
      
      
      return adminAxios<GetProjectResponse>(
      {url: `/api/admin/projects/histories`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetListOfProjectHistoryQueryKey = (params: GetListOfProjectHistoryParams,) => {
    return [`/api/admin/projects/histories`, ...(params ? [params]: [])] as const;
    }

    
export const getGetListOfProjectHistoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjectHistory>>>, TError = unknown>(params: GetListOfProjectHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetListOfProjectHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getListOfProjectHistory>>> = ({ signal }) => getListOfProjectHistory(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetListOfProjectHistoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getListOfProjectHistory>>>
export type GetListOfProjectHistoryInfiniteQueryError = unknown


export function useGetListOfProjectHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjectHistory>>>, TError = unknown>(
 params: GetListOfProjectHistoryParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListOfProjectHistory>>,
          TError,
          Awaited<ReturnType<typeof getListOfProjectHistory>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetListOfProjectHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjectHistory>>>, TError = unknown>(
 params: GetListOfProjectHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListOfProjectHistory>>,
          TError,
          Awaited<ReturnType<typeof getListOfProjectHistory>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetListOfProjectHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjectHistory>>>, TError = unknown>(
 params: GetListOfProjectHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• ÌéòÏù¥ÏßÄ Ï°∞Ìöå
 */

export function useGetListOfProjectHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getListOfProjectHistory>>>, TError = unknown>(
 params: GetListOfProjectHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetListOfProjectHistoryInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetListOfProjectHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getListOfProjectHistory>>, TError = unknown>(params: GetListOfProjectHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetListOfProjectHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getListOfProjectHistory>>> = ({ signal }) => getListOfProjectHistory(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetListOfProjectHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getListOfProjectHistory>>>
export type GetListOfProjectHistoryQueryError = unknown


export function useGetListOfProjectHistory<TData = Awaited<ReturnType<typeof getListOfProjectHistory>>, TError = unknown>(
 params: GetListOfProjectHistoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListOfProjectHistory>>,
          TError,
          Awaited<ReturnType<typeof getListOfProjectHistory>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetListOfProjectHistory<TData = Awaited<ReturnType<typeof getListOfProjectHistory>>, TError = unknown>(
 params: GetListOfProjectHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListOfProjectHistory>>,
          TError,
          Awaited<ReturnType<typeof getListOfProjectHistory>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetListOfProjectHistory<TData = Awaited<ReturnType<typeof getListOfProjectHistory>>, TError = unknown>(
 params: GetListOfProjectHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• ÌéòÏù¥ÏßÄ Ï°∞Ìöå
 */

export function useGetListOfProjectHistory<TData = Awaited<ReturnType<typeof getListOfProjectHistory>>, TError = unknown>(
 params: GetListOfProjectHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getListOfProjectHistory>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetListOfProjectHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• ÌîÑÎ°úÏ†ùÌä∏ Î™ÖÏúºÎ°ú Í≤ÄÏÉâ
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• Í≤ÄÏÉâ
 */
export const searchHistories = (
    params: SearchHistoriesParams,
 signal?: AbortSignal
) => {
      
      
      return adminAxios<GetProjectHistoryResponse>(
      {url: `/api/admin/projects/histories/search`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSearchHistoriesQueryKey = (params: SearchHistoriesParams,) => {
    return [`/api/admin/projects/histories/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchHistoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof searchHistories>>>, TError = unknown>(params: SearchHistoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchHistoriesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchHistories>>> = ({ signal }) => searchHistories(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchHistoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchHistories>>>
export type SearchHistoriesInfiniteQueryError = unknown


export function useSearchHistoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchHistories>>>, TError = unknown>(
 params: SearchHistoriesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchHistories>>,
          TError,
          Awaited<ReturnType<typeof searchHistories>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchHistoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchHistories>>>, TError = unknown>(
 params: SearchHistoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchHistories>>,
          TError,
          Awaited<ReturnType<typeof searchHistories>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchHistoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchHistories>>>, TError = unknown>(
 params: SearchHistoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• Í≤ÄÏÉâ
 */

export function useSearchHistoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchHistories>>>, TError = unknown>(
 params: SearchHistoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchHistoriesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSearchHistoriesQueryOptions = <TData = Awaited<ReturnType<typeof searchHistories>>, TError = unknown>(params: SearchHistoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchHistoriesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchHistories>>> = ({ signal }) => searchHistories(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchHistoriesQueryResult = NonNullable<Awaited<ReturnType<typeof searchHistories>>>
export type SearchHistoriesQueryError = unknown


export function useSearchHistories<TData = Awaited<ReturnType<typeof searchHistories>>, TError = unknown>(
 params: SearchHistoriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchHistories>>,
          TError,
          Awaited<ReturnType<typeof searchHistories>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchHistories<TData = Awaited<ReturnType<typeof searchHistories>>, TError = unknown>(
 params: SearchHistoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchHistories>>,
          TError,
          Awaited<ReturnType<typeof searchHistories>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchHistories<TData = Awaited<ReturnType<typeof searchHistories>>, TError = unknown>(
 params: SearchHistoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î†• Í≤ÄÏÉâ
 */

export function useSearchHistories<TData = Awaited<ReturnType<typeof searchHistories>>, TError = unknown>(
 params: SearchHistoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchHistories>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchHistoriesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶ÑÏúºÎ°ú Ï§ëÎ≥µÏ≤¥ÌÅ¨Î•º Ìï®
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ï§ëÎ≥µ Ï≤¥ÌÅ¨
 */
export const checkProjectName = (
    params: CheckProjectNameParams,
 signal?: AbortSignal
) => {
      
      
      return adminAxios<APIResponseString>(
      {url: `/api/admin/projects/check`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCheckProjectNameQueryKey = (params: CheckProjectNameParams,) => {
    return [`/api/admin/projects/check`, ...(params ? [params]: [])] as const;
    }

    
export const getCheckProjectNameInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof checkProjectName>>>, TError = unknown>(params: CheckProjectNameParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckProjectNameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkProjectName>>> = ({ signal }) => checkProjectName(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckProjectNameInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof checkProjectName>>>
export type CheckProjectNameInfiniteQueryError = unknown


export function useCheckProjectNameInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkProjectName>>>, TError = unknown>(
 params: CheckProjectNameParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkProjectName>>,
          TError,
          Awaited<ReturnType<typeof checkProjectName>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckProjectNameInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkProjectName>>>, TError = unknown>(
 params: CheckProjectNameParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkProjectName>>,
          TError,
          Awaited<ReturnType<typeof checkProjectName>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckProjectNameInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkProjectName>>>, TError = unknown>(
 params: CheckProjectNameParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ï§ëÎ≥µ Ï≤¥ÌÅ¨
 */

export function useCheckProjectNameInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkProjectName>>>, TError = unknown>(
 params: CheckProjectNameParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckProjectNameInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCheckProjectNameQueryOptions = <TData = Awaited<ReturnType<typeof checkProjectName>>, TError = unknown>(params: CheckProjectNameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckProjectNameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkProjectName>>> = ({ signal }) => checkProjectName(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckProjectNameQueryResult = NonNullable<Awaited<ReturnType<typeof checkProjectName>>>
export type CheckProjectNameQueryError = unknown


export function useCheckProjectName<TData = Awaited<ReturnType<typeof checkProjectName>>, TError = unknown>(
 params: CheckProjectNameParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkProjectName>>,
          TError,
          Awaited<ReturnType<typeof checkProjectName>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckProjectName<TData = Awaited<ReturnType<typeof checkProjectName>>, TError = unknown>(
 params: CheckProjectNameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkProjectName>>,
          TError,
          Awaited<ReturnType<typeof checkProjectName>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckProjectName<TData = Awaited<ReturnType<typeof checkProjectName>>, TError = unknown>(
 params: CheckProjectNameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌîÑÎ°úÏ†ùÌä∏ Ï§ëÎ≥µ Ï≤¥ÌÅ¨
 */

export function useCheckProjectName<TData = Awaited<ReturnType<typeof checkProjectName>>, TError = unknown>(
 params: CheckProjectNameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkProjectName>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckProjectNameQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



